#!/usr/bin/env python3
# Copyright (C) 2011 Gregor Richards
# 
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.

import argparse
import collections
import os
import subprocess
import sys
import tempfile

# parse command-line arguments

def parse_args():
    parser = argparse.ArgumentParser(description='Run a command in a UML sandbox.')

    parser.add_argument(
        '--verbose', '-v', action='store_true',
        help='verbose mode: show debugging output')

    group = parser.add_argument_group('mount options')
    group.add_argument(
        '--base-mounts', action='store_true',
        help='use base set of mount points')
    group.add_argument(
        '--mount', metavar='DIR', action='append', default=[],
        help='share a directory, read-only')
    group.add_argument(
        '--mount-write', metavar='DIR', action='append', default=[],
        help='share a directory, read-write')
    group.add_argument(
        '--translate', nargs=2, metavar=('GUEST', 'HOST'), action='append', default=[],
        help='share a directory with a different name, read-only')
    group.add_argument(
        '--translate-write', nargs=2, metavar=('GUEST', 'HOST'), action='append', default=[],
        help='share a directory with a different name, read-write')

    group = parser.add_argument_group('execution options')
    group.add_argument(
        '--cwd', metavar='DIR',
        help='set cwd in guest to DIR')
    group.add_argument(
        '--env', metavar='VAR=VALUE', action='append', default=[],
        help='set VAR to VALUE in the guest environment')
    group.add_argument(
        '--no-stdin', action='store_true',
        help='detach from stdin')
    group.add_argument(
        '--root', action='store_true',
        help='run as root within UML (negates security benefits)')

    group = parser.add_argument_group('communication options')
    group.add_argument(
        '--local', metavar='H:G', action='append', default=[],
        help='forward local TCP port H on host to port G on guest')
    group.add_argument(
        '--remote', metavar='G:A:P', action='append', default=[],
        help='forward remote TCP port G on guest to address A:P')
    group.add_argument(
        '--x11', action='store_true',
        help='enable X11 forwarding')

    group = parser.add_argument_group('execution limits')
    group.add_argument(
        '--timeout', metavar='T', type=int, default=0,
        help='set a timeout of T seconds')
    group.add_argument(
        '--memory', metavar='M', default='256M',
        help='set a memory limit of M (default 256M)')

    group = parser.add_argument_group('paths')
    group.add_argument(
        '--linux', metavar='KERNEL',
        help='use the given UML kernel binary')
    group.add_argument(
        '--mudem', metavar='MUDEM',
        help='use the given mudem binary for port forwarding')
    group.add_argument(
        '--initrd', metavar='INITRD',
        help='use the given initrd file to boot from')

    parser.add_argument(
        'cmd', metavar='X', nargs='+',
        help='command and optional arguments to execute')

    return parser.parse_args(), parser

# build the UML configuration and command

def main():
    args, parser = parse_args()

    finder = Finder()
    istty = os.isatty(1)

    # the command to run
    cmd = ["'" + arg.replace("'", "'\\\''").replace("\n", "'\\n'") + "'"
           for arg in args.cmd]

    # the mount points
    Mount = collections.namedtuple('Mount', 'rrw host guest')
    mounts = {}
    if args.base_mounts:
        for m in ('/usr', '/bin', '/sbin', '/lib', '/lib32', '/lib64', '/etc/alternatives', '/dev'):
            if os.path.isdir(m):
                mounts[m] = Mount(rrw='r', host=m, guest=m)
    for rrw, specs in (('r', args.mount), ('rw', args.mount_write)):
        for spec in specs:
            mdir = os.path.abspath(spec)
            mounts[mdir] = Mount(rrw=rrw, host=mdir, guest=mdir)
    for rrw, specs in (('r', args.translate), ('rw', args.translate_write)):
        for guest, host in specs:
            mdir = os.path.abspath(host)
            mounts[guest] = Mount(rrw=rrw, host=mdir, guest=guest)

    # kernel
    linux = finder.locate(args.linux, 'umlbox-linux', 'linux', '/usr/bin/linux')
    if linux is None:
        parser.error('could not find UML kernel; set --linux?')
    if args.verbose:
        print("Found UML kernel " + linux)

    # mudem
    mudem = finder.locate(args.mudem, 'umlbox-mudem')
    mudem_host = [mudem, '0']
    mudem_guest = [mudem, '1']
    for spec in args.local:
        parts = spec.split(":")
        if len(parts) != 2:
            parser.error('expected --local H:G, got --local "{}"'.format(spec))
        mudem_host.append('tcp4-listen:{}'.format(parts[0]))
        mudem_guest.append('tcp4:127.0.0.1:{}'.format(parts[1]))
    for spec in args.remote:
        parts = spec.split(":")
        if len(parts) != 3:
            parser.error('expected --remote G:A:P, got --remote "{}"'.format(spec))
        mudem_host.append('tcp4:{}:{}'.format(parts[1], parts[2]))
        mudem_guest.append('tcp4-listen:{}'.format(parts[0]))
    if args.x11:
        mudem_host.append('unix:/tmp/.X11-unix/X0')
        mudem_guest.append('tcp4-listen:6000')
    if mudem is None and len(mudemHost) > 2:
        parser.error('could not find umlbox-mudem; set --mudem?')

    # child's cwd
    cwd = args.cwd if args.cwd is not None else os.getcwd()

    # child's extra environment
    env = {}
    for spec in args.env:
        parts = spec.replace('\n', r'\n').replace('\0', r'\0').split('=', 1)
        if len(parts) != 2:
            parser.error('expected --env VAR=VALUE, got --env "{}"'.format(spec))
        env[parts[0].replace(' ', '_')] = parts[1]

    # find initrd
    initrd = finder.locate(args.initrd, 'umlbox-initrd.gz')
    if initrd is None:
        parser.error('could not find umlbox-initrd.gz; set --initrd?')
    if args.verbose:
        print("Found initrd " + initrd)

    # sanity check the environment
    if not ("HOME" in os.environ):
        # UML barfs if it doesn't have a HOME
        os.environ["HOME"] = "/tmp"

    # make the basic setup
    confs = 'setuid {}\nsetgid {}\n'.format(os.getuid(), os.getgid())
    ttycat = ""
    if not istty:
        confs += "ttyraw\n"
        ttycat = " | cat"

    # figure out the hostmount configuration
    mountPaths = list(mounts.keys())
    mountPaths.sort(key=lambda x: len(x))

    # and make the hostmount commands
    for path in mountPaths:
        mount = mounts[path]
        confs += "hostmount " + mount.rrw + " " + mount.host + " " + mount.guest + "\n"

    # Filesystems/basic networking
    confs += ("mount tmpfs /tmp tmpfs\n" +
              "mount proc /proc proc\n" +
              "mount sysfs /sys sysfs\n" +
              "run root / /sbin/ifconfig lo 127.0.0.1\n")

    # Full networking (if requested)
    if len(mudem_guest) > 2:
        confs += ("input ../tty2\n" +
                  "output ../tty2\n" +
                  "error ../tty1\n" +
                  "ttyraw\n"
                  "daemon root / " + " ".join(mudem_guest) + "\n")

    # Process control
    confs += ("timeout " + str(args.timeout) + "\n" +
              "input ../tty1\n" +
              "output ../tty1\n")
    if not istty:
        confs += "ttyraw\n"

    # Extra environment variables
    for k, v in env.items():
        confs += "env " + k + " " + v + "\n"

    # And finally, the command
    runas = 'root' if args.root else 'user'
    confs += "run " + runas + " " + cwd + " " + " ".join(cmd) + ttycat + "\n"
    if args.verbose:
        print("Configuration:\n" + confs + "\n")

    # Pad to block boundary, to avoid ubd from wrapping around
    if len(confs) % 512 != 0:
        confs += "\0" * (512 - len(confs) % 512)

    # set up UML communication lines
    cmd_fd = os.dup(1)
    debug_fd = 2 if args.verbose else subprocess.DEVNULL
    pass_fds = [cmd_fd]

    cmd_con = '{},fd:{}'.format('null' if args.no_stdin else 'fd:0', cmd_fd)
    mudem_con = 'null'
    debug_con = 'null,{}'.format('fd:2' if args.verbose else 'null')

    # Our mudem host
    mudem_proc = None
    if len(mudem_host) > 2:
        mudem_proc = subprocess.Popen(mudem_host, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        mudem_out, mudem_in = mudem_proc.stdout.fileno(), mudem_proc.stdin.fileno()
        mudem_con = 'fd:{},fd:{}'.format(mudem_out, mudem_in)
        pass_fds.extend([mudem_out, mudem_in])

    # Write out the configuration and run the UML kernel
    with tempfile.NamedTemporaryFile(prefix='umlbox-', suffix='.conf') as conf:
        conf.write(confs.encode())
        conf.flush()

        cmd = [
            linux, 'initrd=' + initrd,
            'mem=' + args.memory,
            'con1=' + cmd_con, 'con2=' + mudem_con, 'con=' + debug_con,
            'ubda=' + conf.name,
        ]
        if args.verbose:
            print("Command: " + str(cmd))
            sys.stdout.flush()
        subprocess.run(cmd, stdout=debug_fd, stderr=debug_fd, pass_fds=pass_fds)

    os.close(cmd_fd)
    if mudem_proc != None:
        mudem_proc.terminate()

# utilities

class Finder:
    def __init__(self):
        self._cwd = os.path.abspath('.')
        self._bin = os.path.abspath(os.path.dirname(sys.argv[0]))

    def locate(self, arg, *names):
        if arg is not None:
            return arg
        for name in names:
            path = os.path.join(self._cwd, name)
            if os.path.exists(path):
                return path
            path = os.path.join(self._bin, name)
            if os.path.exists(path):
                return path
        return None

if __name__ == '__main__':
    main()
