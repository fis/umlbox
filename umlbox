#!/usr/bin/env python3
# Copyright (C) 2011 Gregor Richards
# 
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
# REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
# AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
# INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
# OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.

import argparse
import collections
import os
import shutil
import subprocess
import sys

parser = argparse.ArgumentParser(description='Run a command in a UML sandbox.')
parser.add_argument(
    '--verbose', '-v', action='store_true',
    help='verbose mode')
parser.add_argument(
    '--debug', action='store_true',
    help='keep UML kernel and init output visible')
group = parser.add_argument_group('mount options')
group.add_argument(
    '--base-mounts', action='store_true',
    help='use base set of mount points')
group.add_argument(
    '--mount', metavar='DIR', action='append', default=[],
    help='share a directory, read-only')
group.add_argument(
    '--mount-write', metavar='DIR', action='append', default=[],
    help='share a directory, read-write')
group.add_argument(
    '--translate', nargs=2, metavar=('GUEST', 'HOST'), action='append', default=[],
    help='share a directory with a different name, read-only')
group.add_argument(
    '--translate-write', nargs=2, metavar=('GUEST', 'HOST'), action='append', default=[],
    help='share a directory with a different name, read-write')
group = parser.add_argument_group('execution options')
group.add_argument(
    '--cwd', metavar='DIR',
    help='set cwd in guest to DIR')
group.add_argument(
    '--env', metavar='VAR=VALUE', action='append', default=[],
    help='set VAR to VALUE in the guest environment')
group.add_argument(
    '--no-stdin', action='store_true',
    help='detach from stdin')
group.add_argument(
    '--root', action='store_true',
    help='run as root within UML (negates security benefits)')
group = parser.add_argument_group('communication options')
group.add_argument(
    '--local', metavar='H:G', action='append', default=[],
    help='forward local TCP port H on host to port G on guest')
group.add_argument(
    '--remote', metavar='G:A:P', action='append', default=[],
    help='forward remote TCP port G on guest to address A:P')
group.add_argument(
    '--x11', action='store_true',
    help='enable X11 forwarding')
group = parser.add_argument_group('execution limits')
group.add_argument(
    '--timeout', metavar='T', type=int, default=0,
    help='set a timeout of T seconds')
group.add_argument(
    '--memory', metavar='M', default='256M',
    help='set a memory limit of M (default 256M)')
group = parser.add_argument_group('binaries')
group.add_argument(
    '--linux', metavar='KERNEL',
    help='use the given UML kernel binary')
group.add_argument(
    '--mudem', metavar='MUDEM',
    help='use the given mudem binary for port forwarding')

parser.add_argument(
    'cmd', metavar='X', nargs='+',
    help='command and optional arguments to execute')

args = parser.parse_args()

# globals
bindir = os.path.abspath(os.path.dirname(sys.argv[0]))
pid = str(os.getpid())
uid = str(os.getuid())
gid = str(os.getgid())
istty = False
if os.isatty(1):
    istty = True
conf = "/tmp/" + pid + ".conf"

# the command to run
cmd = ["'" + arg.replace("'", "'\\\''").replace("\n", "'\\n'") + "'"
       for arg in args.cmd]

# the mount points
Mount = collections.namedtuple('Mount', 'rrw host guest')
mounts = {}
if args.base_mounts:
    for m in ('/usr', '/bin', '/sbin', '/lib', '/lib32', '/lib64', '/etc/alternatives', '/dev'):
        if os.path.isdir(m):
            mounts[m] = Mount(rrw='r', host=m, guest=m)
for rrw, specs in (('r', args.mount), ('rw', args.mount_write)):
    for spec in specs:
        mdir = os.path.abspath(spec)
        mounts[mdir] = Mount(rrw=rrw, host=mdir, guest=mdir)
for rrw, specs in (('r', args.translate), ('rw', args.translate_write)):
    for guest, host in specs:
        mdir = os.path.abspath(host)
        mounts[guest] = Mount(rrw=rrw, host=mdir, guest=guest)

# kernel
linux = args.linux
if linux is None:
    linux = os.path.join(bindir, 'umlbox-linux')
    if not os.path.exists(linux):
        linux = os.path.join(bindir, 'linux')
    if not os.path.exists(linux):
        linux = '/usr/bin/linux'
    if not os.path.exists(linux):
        print("Could not find a UML kernel.")
        sys.exit(1)
if args.verbose:
    print("Found UML kernel " + linux)

# mudem
mudem = args.mudem
if mudem is None:
    mudem = os.path.join(bindir, 'umlbox-mudem')
mudemHost = [mudem, '0']
mudemGuest = [mudem, '1']
for spec in args.local:
    parts = spec.split(":")
    if len(parts) != 2:
        parser.error('expected --local H:G, got --local "{}"'.format(spec))
    mudemHost.append('tcp4-listen:{}'.format(parts[0]))
    mudemGuest.append('tcp4:127.0.0.1:{}'.format(parts[1]))
for spec in args.remote:
    parts = spec.split(":")
    if len(parts) != 3:
        parser.error('expected --remote G:A:P, got --remote "{}"'.format(spec))
    mudemHost.append('tcp4:{}:{}'.format(parts[1], parts[2]))
    mudemGuest.append('tcp4-listen:{}'.format(parts[0]))
if args.x11:
    mudemHost.append('unix:/tmp/.X11-unix/X0')
    mudemGuest.append('tcp4-listen:6000')

# child's cwd
cwd = args.cwd if args.cwd is not None else os.getcwd()

# child's extra environment
env = {}
for spec in args.env:
    parts = spec.replace('\n', r'\n').replace('\0', r'\0').split('=', 1)
    if len(parts) != 2:
        parser.error('expected --env VAR=VALUE, got --env "{}"'.format(spec))
    env[parts[0].replace(' ', '_')] = parts[1]

# where to get stdin from
childStdin = 'null' if args.no_stdin else 'fd:0'

# keep init's stdout?
initStdout = args.debug or args.verbose

# find initrd
initrd = bindir + "/../lib/umlbox/umlbox-initrd.gz"
if not os.path.exists(initrd):
    initrd = bindir + "/umlbox-initrd.gz"
if not os.path.exists(initrd):
    print("Could not find umlbox-initrd.gz")
    sys.exit(1)
if args.verbose:
    print("Found initrd " + initrd)

# sanity check the environment
if not ("HOME" in os.environ):
    # UML barfs if it doesn't have a HOME
    os.environ["HOME"] = "/tmp"

# make the basic setup
confs = ("setgid " + gid + "\n" +
         "setuid " + uid + "\n")
ttycat = ""
if not istty:
    confs += "ttyraw\n"
    ttycat = " | cat"

# figure out the hostmount configuration
mountPaths = list(mounts.keys())
mountPaths.sort(key=lambda x: len(x))

# and make the hostmount commands
for path in mountPaths:
    mount = mounts[path]
    confs += "hostmount " + mount.rrw + " " + mount.host + " " + mount.guest + "\n"

# Filesystems/basic networking
confs += ("mount tmpfs /tmp tmpfs\n" +
          "mount proc /proc proc\n" +
          "mount sysfs /sys sysfs\n" +
          "run root / /sbin/ifconfig lo 127.0.0.1\n")

# Full networking (if requested)
if len(mudemGuest) > 2:
    confs += ("input ../tty2\n" +
              "output ../tty2\n" +
              "error ../tty1\n" +
              "ttyraw\n"
              "daemon root / " + " ".join(mudemGuest) + "\n")

# Process control
confs += ("timeout " + str(args.timeout) + "\n" +
          "input ../tty1\n" +
          "output ../tty1\n")
if not istty:
    confs += "ttyraw\n"

# Extra environment variables
for k, v in env.items():
    confs += "env " + k + " " + v + "\n"

# And finally, the command
runas = 'root' if args.root else 'user'
confs += "run " + runas + " " + cwd + " " + " ".join(cmd) + ttycat + "\n"
if args.verbose:
    print("Configuration:\n" + confs + "\n")

# Pad to block boundary, to avoid ubd from wrapping around
if len(confs) % 512 != 0:
    confs += "\0" * (512 - len(confs) % 512)

# Write out the configuration
conff = open(conf, "w")
conff.write(confs)
conff.close()

# open all our new pipes
childStdout = os.dup(1) # To keep output
devnullw = os.open("/dev/null", os.O_WRONLY)
stdoutw = devnullw
stdoutws = "null"
if initStdout:
    stdoutw = None
    stdoutws = "fd:1"
passFds = [childStdout]

# Our mudem host
mudemProc = None
mudemRedir = "null"
if len(mudemHost) > 2:
    mudemProc = subprocess.Popen(mudemHost, stdin=subprocess.PIPE,
        stdout=subprocess.PIPE, close_fds=False)
    mudemOut, mudemIn = mudemProc.stdout.fileno(), mudemProc.stdin.fileno()
    mudemRedir = 'fd:{},fd:{}'.format(mudemOut, mudemIn)
    passFds.extend([mudemOut, mudemIn])

cmd = [linux, "initrd=" + initrd, "ubda=" + conf, "mem=" + args.memory,
    "con1=" + childStdin + ",fd:" + str(childStdout),
    "con2=" + mudemRedir,
    "con=null," + stdoutws]
if args.verbose:
    print("Command: " + str(cmd))
    sys.stdout.flush()

subprocess.run(cmd, stdout=stdoutw, stderr=devnullw, pass_fds=passFds)
os.close(devnullw)
os.close(childStdout)

if mudemProc != None:
    mudemProc.terminate()

os.unlink(conf)
